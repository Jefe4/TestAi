# Multi-Agent System Documentation

## Overview

This document provides an overview of the Multi-Agent System (MAS), a Python-based framework designed to orchestrate complex tasks by distributing them among specialized AI agents. The system can analyze user queries, formulate execution plans (sequential or parallel), and manage interactions with various external AI model APIs.

## Core Components

The system is comprised of several key components that work together:

### 1. `Coordinator`
The `Coordinator` is the central brain of the system. Its primary responsibilities include:
- Initializing and managing all available agents.
- Receiving user queries.
- Invoking the `TaskAnalyzer` to understand the query and generate an execution plan.
- Using the `RoutingEngine` to select the appropriate agent(s) based on the plan or query analysis.
- Executing the plan, which may involve dispatching tasks to agents in sequence or in parallel.
- Handling input/output chaining between steps in a plan.
- Returning the final result to the user.

### 2. `TaskAnalyzer`
The `TaskAnalyzer` is responsible for interpreting the user's query and decomposing it into a structured `execution_plan`. It determines:
- The nature of the query (e.g., simple Q&A, code generation, multi-step analysis).
- The sequence of operations or tasks required.
- Whether tasks can be performed in parallel (using "parallel blocks").
- How inputs for each step should be mapped (e.g., from the original query, or from the output of a previous step).
- How outputs of steps should be identified for potential future reference.

### 3. `RoutingEngine`
The `RoutingEngine` takes the analysis result (including any execution plan) from the `TaskAnalyzer` and the list of available agents to:
- Select the specific agent instances best suited for each task in the plan.
- If no explicit plan is provided, it can suggest agents based on the query type or other heuristics.
- It validates if agents specified in a plan are available and active.

### 4. `Agents` (`BaseAgent` and Specialized Agents)
- **`BaseAgent`**: An abstract class that defines the common interface for all agents. Each agent must implement methods like `process_query` and `get_capabilities`.
- **Specialized Agents**: Concrete implementations of `BaseAgent`, tailored to interact with specific AI models or perform particular types of tasks. Examples include:
    - `ClaudeAgent`: For interacting with Anthropic's Claude models.
    - `DeepSeekAgent`: For DeepSeek AI models.
    - `GeminiAgent`: For Google's Gemini models.
    - `CursorAgent`: (Hypothetical) For Cursor AI, focusing on code.
    - `WindsurfAgent`: (Hypothetical) For a Windsurf AI, focusing on web development.

Each agent encapsulates the logic for communicating with its specific backend API and processing queries according to its capabilities.

### 5. `APIManager`
The `APIManager` handles all external API interactions for agents that require them (e.g., ClaudeAgent, DeepSeekAgent). Its responsibilities include:
- Managing API keys and base URLs for different services (loaded from configuration).
- Making HTTP requests asynchronously (using `httpx`).
- Handling standard request/response logic, including authentication headers and error handling.
- Providing a consistent interface for agents to make API calls without dealing with the underlying HTTP complexities.

## Key Features

- **Sequential Task Execution**: Tasks can be chained together, where the output of one step can be used as the input for the next.
- **Parallel Task Execution**: The system supports "parallel blocks" in execution plans, allowing multiple independent branches of tasks to be executed concurrently. This is useful for tasks like performing different types_of_analysis on the same input simultaneously.
- **Input/Output Chaining**: Flexible input mapping allows steps to use the original query, outputs from previous steps (identified by `output_id`), or templated strings combining multiple sources.
- **Dynamic Agent Configuration**: Agents and their API credentials (keys, base URLs) are configured externally via a YAML file (`agent_configs.yaml`), allowing for easy management and updates without code changes.
- **Asynchronous Operations**: Core operations, including API calls made by agents and the execution of parallel branches, are asynchronous for improved performance and responsiveness.

## Execution Plans

Execution plans are the core data structure used by the `Coordinator` to manage how a query is processed. They are typically generated by the `TaskAnalyzer`. A plan is a list of "step definitions".

- **Sequential Steps**: Each item in the list is a dictionary defining a step, including:
    - `agent_name`: The agent to execute the step.
    - `input_mapping`: A dictionary specifying how to construct the input for the agent for this step (e.g., `prompt`, `system_prompt`). Sources can be the `original_query` or `ref:previous_step.content` or `ref:some_output_id.field_path`.
    - `output_id`: A unique identifier for the output of this step, allowing it to be referenced by subsequent steps.
    - `agent_config_overrides`: Optional parameters to override the agent's default configuration for this specific step.

- **Parallel Blocks**: A special type of step definition:
    - `type: "parallel_block"`
    - `task_description`: A description of the parallel operation.
    - `branches`: A list of branches, where each branch is itself a list of sequential step definitions (as described above). Each branch executes independently.
    - `output_id`: An identifier for the aggregated output of the parallel block. The results from each branch are collected under this ID.

## Configuration

- **Agent Configurations**: Agent settings, including API keys, model names, and other parameters, are managed in `multi-agent-system/src/config/agent_configs.yaml`.
- **API Keys**: It is crucial to replace placeholder API keys in `agent_configs.yaml` with actual keys for the respective services. Keys can also be set via environment variables (e.g., `DEEPSEEK_API_KEY`, `CLAUDE_API_KEY`, `GEMINI_API_KEY`). The system prioritizes environment variables if both are present for a service's API key.

## Future Enhancements (Optional)

- More sophisticated error handling and retry mechanisms.
- Enhanced state management for long-running conversations or tasks.
- Tool usage capabilities for agents.
- More advanced input/output templating and transformation.
- UI for interacting with the system.
- Persistent storage for task history and results.
